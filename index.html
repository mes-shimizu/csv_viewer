<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Container Delivery Scheduler</title>
    <!-- Tailwind CSSをCDN経由で読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google FontsからInterフォントを読み込み -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
        .hidden-file-input { display: none; }
        [contenteditable="true"]:focus { outline-color: #3b82f6; background-color: #eff6ff; }
        
        /* スケジュールビューのスタイル */
        .schedule-grid {
            display: grid;
            grid-template-columns: 120px repeat(15, 1fr); /* 5:00-20:00の15時間 */
            overflow-x: auto;
        }
        .timeline-header {
            grid-column: 2 / -1;
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            text-align: center;
            font-size: 12px;
            color: #6b7280;
            position: sticky;
            top: 0;
            background-color: #f9fafb;
            z-index: 20;
        }
        .driver-lane {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: 120px repeat(15, 1fr);
            border-bottom: 1px solid #e5e7eb;
            position: relative;
            min-height: 5rem;
        }
        .driver-name {
            grid-column: 1 / 2;
            padding: 0.5rem;
            font-weight: 500;
            position: sticky;
            left: 0;
            background-color: white;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
        }
        .driver-schedule {
            grid-column: 2 / -1;
            position: relative;
            background-image: linear-gradient(to right, #e5e7eb 1px, transparent 1px);
            background-size: calc(100% / 15) 100%;
        }
        .schedule-block {
            position: absolute;
            top: 5px;
            height: calc(100% - 10px);
            background-color: #fef08a;
            border: 1px solid #facc15;
            border-radius: 4px;
            cursor: move;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            padding: 0 5px;
            line-height: 1.3;
            z-index: 1;
        }
        .unassigned-block {
             background-color: #d1d5db; /* gray-300 */
             border-color: #9ca3af; /* gray-400 */
        }
        .overlapping-block {
            background-color: #f87171; /* red-400 */
            border-color: #ef4444; /* red-500 */
            z-index: 2; /* 重複したブロックを前面に表示 */
        }
        .resize-handle {
            position: absolute;
            top: 0;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
        }
        .resize-handle-left { left: 0; }
        .resize-handle-right { right: 0; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">配送スケジュールプランナー</h1>
            <p class="mt-2 text-gray-600">ドライバーリストと配車計画を読み込み、スケジュールを編集します。</p>
        </header>

        <!-- 操作セクション -->
        <div class="max-w-4xl mx-auto bg-white rounded-lg shadow-md p-6 mb-8">
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 items-start">
                <!-- ファイル選択（ドライバー） -->
                <div class="flex flex-col items-center">
                    <label for="driverFileInput" class="cursor-pointer bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition w-full text-center">1. ドライバーリスト読込</label>
                    <input type="file" id="driverFileInput" class="hidden-file-input" accept=".csv">
                    <p id="driverFileName" class="mt-2 text-xs text-gray-500">未選択</p>
                </div>
                <!-- ファイル選択（配車計画） -->
                <div class="flex flex-col items-center">
                    <label for="planFileInput" class="cursor-pointer bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition w-full text-center">2. 配車計画読込</label>
                    <input type="file" id="planFileInput" class="hidden-file-input" accept=".csv">
                    <p id="planFileName" class="mt-2 text-xs text-gray-500">未選択</p>
                </div>
                <!-- 表示切替 -->
                <div class="flex justify-center border border-gray-200 rounded-lg p-1 w-full">
                    <button id="viewTableBtn" class="px-4 py-2 text-sm font-medium rounded-md bg-blue-100 text-blue-700 w-1/2">テーブル</button>
                    <button id="viewScheduleBtn" class="px-4 py-2 text-sm font-medium rounded-md w-1/2">スケジュール</button>
                </div>
                <!-- 保存 -->
                 <div class="flex flex-col items-center">
                    <button id="saveButton" disabled class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition w-full disabled:bg-gray-400">CSVを保存</button>
                    <select id="encodingSelector" class="mt-2 rounded-md border-gray-300 shadow-sm w-full text-xs">
                        <option value="UTF-8">文字コード: UTF-8</option>
                        <option value="Shift_JIS" selected>文字コード: Shift_JIS</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- テーブル表示セクション -->
        <div id="tableView" class="bg-white rounded-lg shadow-md overflow-hidden">
            <div class="overflow-x-auto">
                <table id="csvTable" class="min-w-full divide-y divide-gray-200">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- スケジュール表示セクション -->
        <div id="scheduleView" class="hidden bg-white rounded-lg shadow-md overflow-hidden">
            <div class="schedule-grid">
                <div class="driver-name" style="grid-row: 1; border-bottom: 1px solid #e5e7eb;"></div>
                <div id="timelineHeader" class="timeline-header"></div>
                <div id="scheduleBody" style="grid-column: 1 / -1; display: contents;"></div>
            </div>
        </div>
    </div>

    <script>
        // DOM要素
        const driverFileInput = document.getElementById('driverFileInput');
        const planFileInput = document.getElementById('planFileInput');
        const driverFileNameDisplay = document.getElementById('driverFileName');
        const planFileNameDisplay = document.getElementById('planFileName');
        const encodingSelector = document.getElementById('encodingSelector');
        const saveButton = document.getElementById('saveButton');
        const viewTableBtn = document.getElementById('viewTableBtn');
        const viewScheduleBtn = document.getElementById('viewScheduleBtn');
        const tableView = document.getElementById('tableView');
        const scheduleView = document.getElementById('scheduleView');

        // アプリケーションの状態
        let originalPlanFileName = 'plan.csv';
        let planHeaders = [];
        let planData = [];
        let driverData = []; // { driver_name: string, head_id: string }[]
        let columnIndices = {};
        
        const SCHEDULE_START_HOUR = 5;
        const SCHEDULE_END_HOUR = 20;

        // --- イベントリスナー ---
        driverFileInput.addEventListener('change', (e) => handleFileSelect(e, 'driver'));
        planFileInput.addEventListener('change', (e) => handleFileSelect(e, 'plan'));
        saveButton.addEventListener('click', handleSave);
        viewTableBtn.addEventListener('click', () => switchView('table'));
        viewScheduleBtn.addEventListener('click', () => switchView('schedule'));

        function handleFileSelect(event, type) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                if (type === 'driver') {
                    driverFileNameDisplay.textContent = file.name;
                    parseDriverCSV(e.target.result);
                } else if (type === 'plan') {
                    originalPlanFileName = file.name;
                    planFileNameDisplay.textContent = file.name;
                    parsePlanCSV(e.target.result);
                    findColumnIndices();
                }
                renderAll();
                if(planData.length > 0) saveButton.disabled = false;
            };
            reader.readAsText(file, encodingSelector.value);
        }

        function handleSave() {
            const csvContent = generateCSV();
            downloadCSV(csvContent, `edited_${originalPlanFileName}`);
        }

        function switchView(view) {
            if (view === 'table') {
                tableView.classList.remove('hidden');
                scheduleView.classList.add('hidden');
                viewTableBtn.classList.add('bg-blue-100', 'text-blue-700');
                viewScheduleBtn.classList.remove('bg-blue-100', 'text-blue-700');
            } else {
                tableView.classList.add('hidden');
                scheduleView.classList.remove('hidden');
                viewScheduleBtn.classList.add('bg-blue-100', 'text-blue-700');
                viewTableBtn.classList.remove('bg-blue-100', 'text-blue-700');
                renderSchedule();
            }
        }

        // --- データ処理 ---
        function parseDriverCSV(text) {
            const rows = text.trim().split(/\r?\n/).filter(row => row);
            const headers = rows.length > 0 ? rows[0].split(',').map(h => h.trim()) : [];
            const driverNameIndex = headers.indexOf('driver_name');
            const headIdIndex = headers.indexOf('head_id');
            driverData = rows.slice(1).map(row => {
                const cells = row.split(',').map(cell => cell.trim());
                return {
                    driver_name: cells[driverNameIndex] || '',
                    head_id: cells[headIdIndex] || ''
                };
            });
        }

        function parsePlanCSV(text) {
            const rows = text.trim().split(/\r?\n/).filter(row => row);
            planHeaders = rows.length > 0 ? rows[0].split(',').map(h => h.trim()) : [];
            planData = rows.slice(1).map((row, index) => ({
                id: index,
                data: row.split(',').map(cell => cell.trim())
            }));
        }

        function findColumnIndices() {
            const findIndex = (...keys) => {
                for (const key of keys) {
                    const index = planHeaders.indexOf(key);
                    if (index !== -1) return index;
                }
                return -1;
            };
            columnIndices = {
                order: findIndex('注文番号', 'order_no'),
                seq: findIndex('シーケンス番号', 'seq_no'),
                work: findIndex('作業時間', 'work_time', '作業日時'),
                start: findIndex('出発時間', 'departure_time', '出発日時'),
                end: findIndex('帰着時間', 'arrival_time', '帰着日時'),
                container: findIndex('コンテナ番号', 'container_no'),
                headId: findIndex('ヘッドID', 'head_id'),
                driver: findIndex('ドライバー', 'driver_name', 'ドライバ名'),
                workPlace: findIndex('作業場所', 'work_place')
            };
        }

        function generateCSV() {
            const tableHeaders = ['注文番号', 'シーケンス番号', '作業時間', '出発時間', '帰着時間', 'コンテナ番号', 'ヘッドID', 'ドライバー', '作業場所', '積み置き'];
            const headerRow = tableHeaders.map(h => `"${h}"`).join(',');
            
            const headerKeyMap = {
                '注文番号': 'order', 'シーケンス番号': 'seq', '作業時間': 'work',
                '出発時間': 'start', '帰着時間': 'end', 'コンテナ番号': 'container',
                'ヘッドID': 'headId', 'ドライバー': 'driver', '作業場所': 'workPlace'
            };

            const dataRows = planData.map(rowObj => {
                const newRow = [];
                tableHeaders.forEach(header => {
                    if (header === '積み置き') {
                        const timeStr = rowObj.data[columnIndices.start] || '';
                        const hour = parseInt(timeStr.split(':')[0], 10);
                        newRow.push(!isNaN(hour) && hour < 11 ? 'TRUE' : 'FALSE');
                    } else {
                        const key = headerKeyMap[header];
                        const dataIndex = columnIndices[key];
                        newRow.push((dataIndex > -1 && rowObj.data[dataIndex]) ? rowObj.data[dataIndex] : '');
                    }
                });
                return newRow.map(cell => `"${cell}"`).join(',');
            });

            return [headerRow, ...dataRows].join('\n');
        }

        function downloadCSV(csvContent, fileName) {
            const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
            const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // --- 描画 ---
        function renderAll() {
            renderTable();
            renderSchedule();
        }

        function renderTable() {
            const tableHead = document.querySelector('#csvTable thead');
            const tableBody = document.querySelector('#csvTable tbody');
            tableHead.innerHTML = '';
            tableBody.innerHTML = '';

            const displayHeaders = ['注文番号', 'シーケンス番号', '作業時間', '出発時間', '帰着時間', 'コンテナ番号', 'ヘッドID', 'ドライバー', '作業場所', '積み置き'];
            const headerRow = document.createElement('tr');
            displayHeaders.forEach(headerText => {
                headerRow.appendChild(Object.assign(document.createElement('th'), { 
                    textContent: headerText,
                    className: 'px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider'
                }));
            });
            tableHead.appendChild(headerRow);

            const headerKeyMap = {
                '注文番号': 'order', 'シーケンス番号': 'seq', '作業時間': 'work',
                '出発時間': 'start', '帰着時間': 'end', 'コンテナ番号': 'container',
                'ヘッドID': 'headId', 'ドライバー': 'driver', '作業場所': 'workPlace'
            };

            planData.forEach(rowObj => {
                const tr = document.createElement('tr');
                tr.dataset.id = rowObj.id;

                displayHeaders.forEach(header => {
                    const td = document.createElement('td');
                    td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-800';

                    if (header === '積み置き') {
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        const timeStr = rowObj.data[columnIndices.start] || '';
                        const hour = parseInt(timeStr.split(':')[0], 10);
                        if (!isNaN(hour) && hour < 11) checkbox.checked = true;
                        td.appendChild(checkbox);
                    } else {
                        const key = headerKeyMap[header];
                        const dataIndex = columnIndices[key];
                        if (dataIndex !== undefined && dataIndex > -1) {
                            td.textContent = rowObj.data[dataIndex] || '';
                            td.setAttribute('contenteditable', 'true');
                            td.dataset.col = dataIndex;
                        } else {
                            td.textContent = '';
                        }
                    }
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });
        }

        function renderSchedule() {
            const timelineHeader = document.getElementById('timelineHeader');
            const scheduleBody = document.getElementById('scheduleBody');
            timelineHeader.innerHTML = '';
            scheduleBody.innerHTML = '';

            for (let i = SCHEDULE_START_HOUR; i < SCHEDULE_END_HOUR; i++) {
                timelineHeader.appendChild(Object.assign(document.createElement('div'), { textContent: `${i}:00` }));
            }

            scheduleBody.innerHTML = '';
            
            // 1. 未割当レーンを描画
            const unassignedJobs = planData.filter(job => !job.data[columnIndices.driver] && !job.data[columnIndices.headId]);
            const unassignedLane = createLane('未割当', { head_id: '', driver_name: '未割当' }, 0);
            scheduleBody.appendChild(unassignedLane);
            renderBlocksForDriver(unassignedLane.querySelector('.driver-schedule'), unassignedJobs, true);

            // 2. ドライバーレーンを描画
            driverData.forEach((driverInfo, i) => {
                const lane = createLane(driverInfo.driver_name, driverInfo, i + 1);
                scheduleBody.appendChild(lane);
                const driverJobs = planData.filter(job => job.data[columnIndices.driver] === driverInfo.driver_name);
                renderBlocksForDriver(lane.querySelector('.driver-schedule'), driverJobs, false);
            });
        }

        function createLane(id, info, rowIndex) {
            const lane = document.createElement('div');
            lane.className = 'driver-lane';
            lane.style.gridRow = `${rowIndex + 2}`;
            lane.dataset.driverName = info.driver_name;

            const nameDiv = document.createElement('div');
            nameDiv.className = 'driver-name';
            nameDiv.innerHTML = `<span class="font-bold text-gray-800 text-sm">${info.head_id}</span><span class="text-gray-600 text-xs">${info.driver_name}</span>`;
            lane.appendChild(nameDiv);

            const scheduleDiv = document.createElement('div');
            scheduleDiv.className = 'driver-schedule';
            lane.appendChild(scheduleDiv);
            return lane;
        }

        function renderBlocksForDriver(container, jobs, isUnassigned) {
            const viewStartMinutes = SCHEDULE_START_HOUR * 60;
            const viewTotalMinutes = (SCHEDULE_END_HOUR - SCHEDULE_START_HOUR) * 60;

            jobs.forEach(jobA => {
                const startA = timeToMinutes(jobA.data[isUnassigned ? columnIndices.work : columnIndices.start]);
                const endA = isUnassigned ? startA + 120 : timeToMinutes(jobA.data[columnIndices.end]);
                if (startA === null || endA === null || endA <= startA) return;

                const isOverlapping = jobs.some(jobB => {
                    if (jobA.id === jobB.id) return false;
                    const startB = timeToMinutes(jobB.data[isUnassigned ? columnIndices.work : columnIndices.start]);
                    const endB = isUnassigned ? startB + 120 : timeToMinutes(jobB.data[columnIndices.end]);
                    if (startB === null || endB === null || endB <= startB) return false;
                    return startA < endB && endA > startB;
                });

                const block = document.createElement('div');
                block.className = 'schedule-block';
                if (isUnassigned) block.classList.add('unassigned-block');
                if (isOverlapping && !isUnassigned) block.classList.add('overlapping-block');
                block.dataset.id = jobA.id;
                
                const seqNo = jobA.data[columnIndices.seq] || '';
                const workPlace = jobA.data[columnIndices.workPlace] || '';
                block.innerHTML = `<span class="font-semibold">${seqNo}</span><span class="text-gray-700">${workPlace}</span>`;
                
                const clippedStart = Math.max(startA, viewStartMinutes);
                const clippedEnd = Math.min(endA, SCHEDULE_END_HOUR * 60);
                const left = ((clippedStart - viewStartMinutes) / viewTotalMinutes) * 100;
                const width = ((clippedEnd - clippedStart) / viewTotalMinutes) * 100;

                if (width <= 0) return;
                block.style.left = `${left}%`;
                block.style.width = `${width}%`;

                ['left', 'right'].forEach(side => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle resize-handle-${side}`;
                    block.appendChild(handle);
                });

                container.appendChild(block);
                addBlockInteractions(block);
            });
        }

        function timeToMinutes(timeStr) {
            if (!timeStr) return null;
            const match = timeStr.match(/(\d{1,2}):(\d{2})/);
            if (!match) return null;
            return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        }

        function minutesToTime(totalMinutes) {
            const roundedTotalMinutes = Math.round(totalMinutes);
            const hours = Math.floor(roundedTotalMinutes / 60) % 24;
            const minutes = roundedTotalMinutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        
        let activeInteraction = null;
        function addBlockInteractions(block) {
            block.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const type = e.target.classList.contains('resize-handle-left') ? 'resize-left' :
                             e.target.classList.contains('resize-handle-right') ? 'resize-right' : 'move';
                activeInteraction = { type, block, startX: e.clientX, startWidth: block.offsetWidth, startLeft: block.offsetLeft, containerRect: block.parentElement.getBoundingClientRect() };
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (!activeInteraction) return;
            e.preventDefault();
            const { type, block, startX, startLeft, startWidth } = activeInteraction;
            const dx = e.clientX - startX;
            if (type === 'move') {
                block.style.left = `${Math.max(0, startLeft + dx)}px`;
            } else if (type === 'resize-right') {
                block.style.width = `${Math.max(10, startWidth + dx)}px`;
            } else if (type === 'resize-left') {
                block.style.width = `${Math.max(10, startWidth - dx)}px`;
                block.style.left = `${Math.max(0, startLeft + dx)}px`;
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (!activeInteraction) return;
            const { block, containerRect } = activeInteraction;
            
            const newLeftPercent = (block.offsetLeft / containerRect.width) * 100;
            const newWidthPercent = (block.offsetWidth / containerRect.width) * 100;
            block.style.left = `${newLeftPercent}%`;
            block.style.width = `${newWidthPercent}%`;

            const viewStartMinutes = SCHEDULE_START_HOUR * 60;
            const viewTotalMinutes = (SCHEDULE_END_HOUR - SCHEDULE_START_HOUR) * 60;
            const startMinutes = (newLeftPercent / 100) * viewTotalMinutes + viewStartMinutes;
            const endMinutes = startMinutes + (newWidthPercent / 100) * viewTotalMinutes;

            const targetRow = planData.find(d => d.id === parseInt(block.dataset.id));
            if (!targetRow) { activeInteraction = null; return; }

            const dropTarget = document.elementFromPoint(e.clientX, e.clientY)?.closest('.driver-lane');
            const targetDriverName = dropTarget?.dataset.driverName;
            
            if (targetDriverName && targetDriverName !== '未割当') {
                const driverInfo = driverData.find(d => d.driver_name === targetDriverName);
                if (driverInfo) {
                    targetRow.data[columnIndices.driver] = driverInfo.driver_name;
                    targetRow.data[columnIndices.headId] = driverInfo.head_id;
                    targetRow.data[columnIndices.start] = minutesToTime(startMinutes);
                    targetRow.data[columnIndices.end] = minutesToTime(endMinutes);
                    renderAll();
                }
            } 
            else if (!block.classList.contains('unassigned-block')) {
                targetRow.data[columnIndices.start] = minutesToTime(startMinutes);
                targetRow.data[columnIndices.end] = minutesToTime(endMinutes);
                renderAll();
            } 
            else {
                renderSchedule();
            }
            
            activeInteraction = null;
        });
    </script>
</body>
</html>
